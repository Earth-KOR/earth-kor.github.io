
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="이상권의 개발노트">
    <title>Category: Javascript - 이상권의 개발노트</title>
    <meta name="author" content="이상권">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="이상권의 개발노트">
<meta property="og:url" content="https://earth-kor.github.io/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/index.html">
<meta property="og:site_name" content="이상권의 개발노트">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="이상권">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://earth-kor.github.io/assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            이상권의 개발노트
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">이상권</h4>
                
                    <h5 class="sidebar-profile-bio"><p>미래의 백엔드 개발자</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/index"
                            
                            rel="noopener"
                            title="홈"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">홈</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tag" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="기록"
                        >
                        <i class="sidebar-button-icon fa fa-running" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">기록</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Earth-KOR"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.instagram.com/kwon_27_/?hl=ko"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="instagram"
                        >
                        <i class="sidebar-button-icon fab fa-instagram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">instagram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:lsk941017@naver.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/04/04/javascript%20%EB%B0%B0%EC%97%B4%EC%97%90%20%EB%8C%80%ED%95%9C%20%EB%8B%A4%EC%96%91%ED%95%9C%20%EB%A9%94%EC%84%9C%EB%93%9C%20%EC%A0%95%EB%A6%AC/"
                            aria-label=": javascript 배열에 대한 다양한 메서드 정리"
                        >
                            javascript 배열에 대한 다양한 메서드 정리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-04-04T11:17:48-07:00">
	
		    Apr 04, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="javascript-배열에-대한-다양한-메서드-정리"><a href="#javascript-배열에-대한-다양한-메서드-정리" class="headerlink" title="javascript 배열에 대한 다양한 메서드 정리"></a>javascript 배열에 대한 다양한 메서드 정리</h1><h2 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach"></a>1. forEach</h2><p>arr.forEach( function (n) { if ( n % 2 == 0 ) { console.log(n); } );</p>
<p>( Vs for반복문 )</p>
<p>스코프를 더럽히지 않는다.</p>
<ul>
<li>for 구문은 배열의 인덱스를 저장하기 위한 임시 변수 i를 할당했습니다. 사실 이 프로그램은 아주 작아서 임시 변수 할당하는 것은 큰 문제가 안됩니다. 그러나 시스템이 커지고 유지보수를 해야 한다면 언제 사용한지 모르는 i 때문에 가독성이 떨어지게 됩니다.<br>요소 접근 방법 arr[i] vs n</li>
<li>forEach의 콜백 함수의 첫 번째 인자로 각 요소의 값이 들어옵니다. 덕분에 우리는 깔끔한 방법으로 각 요소의 값을 얻을 수 있습니다.</li>
</ul>
<h2 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h2><p>arr.map(function (str) { return str.length; });</p>
<p>( Vs forEach 반복문 )</p>
<p>map은 부모 스코프 영역을 건드리지 않고 콜백 함수만으로 목적을 달성합니다. 다른 코드는 신경쓰지 않아도 됩니다.<br>소개 할 메소드는 함수형 프로그래밍 패러다임에서 아이디어를 착안합니다. 함수형 프로그래밍 패러다임은 순수 함수의 연결로부터 도메인을 해결하는 방법입니다. 순수 함수는 사이드 이펙트를 가지지않는 함수를 말합니다. Input과 Output이 중요할 뿐이지 내부 로직은 다른 영역에 간섭하지 않기 때문에 추적하기 쉽고 간결한 구조가 자연스럽게 형성됩니다.<br>for, forEach 또는 다른 메소드로도 서로의 도메인을 해결할 수 있겠지만, 각 목적에 따라서 사용함으로써 직관적이고 가독성있는 코드를 작성하는데 도움 줄 것입니다.</p>
<h2 id="3-filter"><a href="#3-filter" class="headerlink" title="3. .filter"></a>3. .filter</h2><p>Javascript - filter 패턴 1</p>
<p>Let result = data.filter( x =&gt; { return x.age &gt;= 20 }</p>
<p>Javascript - filter 패턴 2</p>
<p>Let result = data.filter( (x, idx, array) =&gt; { return idx ===0 &amp;&amp; x.age &gt;= 20 });</p>
<p>해당하는 값이 없을 시 빈배열 반환함!</p>
<h2 id="4-find"><a href="#4-find" class="headerlink" title="4. .find"></a>4. .find</h2><p>arr.find( function (n) { return n % 5 == 0 ; ) );</p>
<p>filter는 찾지 못하면 빈 배열을 반환했습니다. 그런데 find는 undefined라고요? 그러면 함수를 연결하여 사용할 수 없는 거 아닌가요? 조금만 생각해보면 find는 빈 배열을 반환할 필요가 없음을 알 수 있습니다. 정상적으로 반환하더라도 이미 배열이 아니기 떄문입니다. 따라서 find의 반환은 항상 배열이 아니기 때문에 어차피 다른 Array 메소드와 연결하여 사용할 일이 없습니다.</p>
<ol start="5">
<li>Reduce</li>
</ol>
<p>reduce 메소드는 위에서 나온 메소드를 모두 대체할 수 있는 아주 유연한 메소드입니다. map, filter, find로 구현할 수 있는 문제라면 reduce로도 구현할 수 있습니다. 하지만 상황에 따라 적절한 메소드를 사용하는 것이 가독성 측면에서 더 유리하겠죠?<br>먼저 reduce의 사용 방법을 봅시다. 조금 특이합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 배열 요소의 합 계산하기</span><br><span class="line">var arr &#x3D; [9, 2, 8, 5, 7];</span><br><span class="line">var sum &#x3D; arr.reduce(function (pre, value) &#123;</span><br><span class="line">   count++;</span><br><span class="line">    return pre + value;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(count); &#x2F;&#x2F; 4</span><br><span class="line">console.log(sum); &#x2F;&#x2F; 31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 배열 요소의 합 계산하기</span><br><span class="line">var arr &#x3D; [9, 2, 8, 5, 7];</span><br><span class="line">var count &#x3D; 0;</span><br><span class="line">var sum &#x3D; arr.reduce(function (pre, value) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    return pre + value;</span><br><span class="line">&#125;, 0); &#x2F;&#x2F; initialValue가 주어졌다!</span><br><span class="line">console.log(sum); &#x2F;&#x2F; 31</span><br><span class="line">console.log(count); &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-indexOf-lastIndexOf"><a href="#6-indexOf-lastIndexOf" class="headerlink" title="6. indexOf() , lastIndexOf()"></a>6. indexOf() , lastIndexOf()</h2><p> indexOf() 함수는 <br>배열 안에서 찾으려는 값(searchElement)과 정확하게 일치(===)하는’첫번째’ element의 index를 리턴합니다. <br>  lastIndexOf() 함수는 <br>배열 안에서 찾으려는 값(searchElement)과 정확하게 일치(===)하는 ‘마지막’ element의 index 를 리턴합니다.<br> <br>두 함수 모두 찾으려는 값이 배열에 없으면 -1을 리턴합니다.</p>
<h2 id="7-Includes"><a href="#7-Includes" class="headerlink" title="7. Includes"></a>7. Includes</h2><p>arr.includes(1); // true<br>arr[0]의 값이 1이므로 true를 리턴합니다.<br> arr.includes(3); // false<br>arr에는 3이라는 값이 없으므로 false를 리턴합니다.<br> arr.includes(1, 1); // false<br>arr[1] 이후에는 1이라는 값이 없으므로 false를 리턴합니다.<br> arr.includes(1, 2); // false<br>두 번째 파라미터인 fromIndex에 배열의 길이보다 크거나 같은 값이 들어가면 무조건 false를 리턴합니다.<br>여기서 배열의 길이는 2인데, fromIndex 자리에 2가 들어갔으므로 false가 리턴되었습니다.<br> arr.includes(2, -1); // true<br>fromIndex 자리에 음수가 들어가면, 실제 시작 index는 ‘배열의 길이 + fromIndex’로 계산됩니다.<br>배열의 길이는 2이고, fromIndex는 -1이므로, <br>실제 검색을 시작하는 index는 1이 됩니다.  (2 + (-1))<br>arr[1]에 2가 있으므로, true가 리턴 되었습니다.</p>
<p>includes() 함수는 내부적으로 값을 비교할 때 ‘===’ 연산자를 사용하기 때문입니다.<br>‘===’ 연산자는 primitive type이 아닌 object를 비교할 때,<br>object의 값이 같은지 비교하는 것이 아니라, 같은 객체를 가리키고 있는지를 비교합니다.</p>
<h2 id="8-Some"><a href="#8-Some" class="headerlink" title="8. Some"></a>8. Some</h2><p>배열에서 값을 찾는 조건을 callback 함수로 전달하고,<br>배열에 조건에 맞는 값이 있는지 여부(boolean)를 리턴하는 하는 함수입니다.<br>조건에 맞는 값이 있으면 true, 조건에 맞는 값이 없으면 false를 리턴합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const arr1 &#x3D; [1, 2, 3, 2];</span><br><span class="line">const arr2 &#x3D; [1, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">function findNumberTwo(element) &#123;</span><br><span class="line">  if(element &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">document.writeln(arr1.some(findNumberTwo)); &#x2F;&#x2F; true</span><br><span class="line">document.writeln(arr2.some(findNumberTwo)); &#x2F;&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>object의 값을 체크할 때는 some() 함수를 사용합니다.</p>
<p>includes() 함수는 primitive type을 체크하는 적절하고,<br>some() 함수는 primitive type 외의 타입을 체크하는데 적절하고,<br>체크 로직을 다양하게 적용할 수 있는 장점이 있습니다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://hianna.tistory.com/403">https://hianna.tistory.com/403</a> [어제 오늘 내일]</p>
<p>출처 : <a target="_blank" rel="noopener" href="https://bblog.tistory.com/300">https://bblog.tistory.com/300</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/04/04/javascript%20%EB%B0%B0%EC%97%B4%EC%97%90%20%EB%8C%80%ED%95%9C%20%EB%8B%A4%EC%96%91%ED%95%9C%20%EB%A9%94%EC%84%9C%EB%93%9C%20%EC%A0%95%EB%A6%AC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/03/06/captruring/"
                            aria-label=": Javascript bubbling captruring"
                        >
                            Javascript bubbling captruring
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-03-06T10:17:48-08:00">
	
		    Mar 06, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="JavaScript-버블링-amp-캡쳐링"><a href="#JavaScript-버블링-amp-캡쳐링" class="headerlink" title="JavaScript 버블링 &amp; 캡쳐링"></a>JavaScript 버블링 &amp; 캡쳐링</h1><h2 id="버블링-bubbling-의-원리"><a href="#버블링-bubbling-의-원리" class="headerlink" title="버블링(bubbling)의 원리"></a>버블링(bubbling)의 원리</h2><p>한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작합니다.</p>
<h2 id="버블링-중단하기"><a href="#버블링-중단하기" class="headerlink" title="버블링 중단하기"></a>버블링 중단하기</h2><p>이벤트 버블링은 타깃 이벤트에서 시작해서 <html> 요소를 거쳐 document 객체를 만날 때까지 각 노드에서 모두 발생합니다. 몇몇 이벤트는 window 객체까지 거슬러 올라가기도 합니다. 이 때도 모든 핸들러가 호출됩니다.</p>
<p>그런데 핸들러에게 이벤트를 완전히 처리하고 난 후 버블링을 중단하도록 명령할 수도 있습니다.</p>
<p>이벤트 객체의 메서드인 event.stopPropagation()를 사용하면 됩니다.</p>
<h2 id="캡처링"><a href="#캡처링" class="headerlink" title="캡처링"></a>캡처링</h2><p>이벤트엔 버블링 이외에도 ‘캡처링(capturing)’ 이라는 흐름이 존재합니다. 실제 코드에서 자주 쓰이진 않지만, 종종 유용한 경우가 있으므로 알아봅시다.</p>
<p>표준 DOM 이벤트에서 정의한 이벤트 흐름엔 3가지 단계가 있습니다.</p>
<p>캡처링 단계 – 이벤트가 하위 요소로 전파되는 단계<br>타깃 단계 – 이벤트가 실제 타깃 요소에 전달되는 단계<br>버블링 단계 – 이벤트가 상위 요소로 전파되는 단계</p>
<p>캡처링과 버블링을 간단히 정의하면 다음과 같다.</p>
<p>캡처링 - window 로부터 이벤트가 발생한 요소까지 이벤트를 전파한다.<br>버블링 - 이벤트가 발생한 요소부터 window 까지 이벤트를 전파한다.</p>
<p>둘의 차이점은 단순히 방향이다.</p>
<p>하위 =&gt; 상위, 상위 =&gt; 하위 개념으로 보면 된다.</p>
<p>이벤트 전파를 원하지 않는다. 어떻게 하는가?</p>
<p>단순히 e.stopPropagation() 메소드를 사용하면 된다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://mygumi.tistory.com/315">https://mygumi.tistory.com/315</a> [마이구미의 HelloWorld]</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/03/06/captruring/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/16/%EC%9B%90%EB%A6%AC/"
                            aria-label=": 자바스크립트 동작 원리"
                        >
                            자바스크립트 동작 원리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-16T08:32:52-08:00">
	
		    Jan 16, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="자바스크립트-동작-원리"><a href="#자바스크립트-동작-원리" class="headerlink" title="자바스크립트 동작 원리"></a>자바스크립트 동작 원리</h1><p>‘’’<br>// ex)<br>console.log(‘Start!’)</p>
<p>setTimeout(() =&gt; {<br>Console.log(’Timeout!’)<br>}, 0)</p>
<p>Promise.resolve(‘Promise!’)<br>.then(res =&gt; console.log(res))</p>
<p>console.log(‘End!’)<br>‘’’</p>
<p>맨 처음 라인에서 엔진은 console.log()를 마주친다 이는 “Start!”라고 값이 콘솔에 찍히고 나서 call stack에 추가된다. 해당 메소드는 call stack에서 빠져나가고 엔진은 계속해서 실행된다.</p>
<p>그 다음 엔진은 call stack으로 들어간 setTimeout메소드를 맞닥뜨린다.setTimeout 메소드는 브라우저의 native 메소드이다.<br />타이머가 끝날때까지 그것의 콜백 함수인 ()=&gt;console.log(‘In timeout’)은되 Web API에 추가된다.<br>비록 우리는 타이머에 0이라는 값을 넣었지만, 콜백은 먼저 Web API에 들어갈 것이고, 그 다음엔 (macro)task queue에 추가될 것이다. (setTimeout은 <b>macro task</b>이다!)</p>
<p>그 다음 엔진은 Promise.resolve() 메소드와 마주침<br>Promise.resolve() 메소드는 call stack에 추가되고, 그다음엔 “Promise!” 라는 값으로 resolve된다<br>해당 메소드의 then 콜백 함수가 micro task queue에 추가된것이다</p>
<p>엔진은 callstack이 비어있는 것을 발견한다<br>Call stack이 비어있기 때문에 엔진은 micro task queue에 작업들이 있는지 체크한다<br>그리고 거기거 promise then의 콜백이 작신의 차례를 기다리고 있는 것을 찾아낸다!<br>그것은 call stack으로 들어가고 promise의 resolve된 값들을 로그로 찍는다.</p>
<p>이제 엔진은 call stack이 비어진 것을 보고 micro task queue를 다시 한번 체크 할 것이다.<br>하지만 이제 microtask queue에는 아무것도 남아 있지 않다</p>
<p>이제 macrotask queue를 체크 할 차례이다!<br>앞서 과정을 반복한다!</p>
<p>출처 : <a target="_blank" rel="noopener" href="https://kkangdda.tistory.com/77">https://kkangdda.tistory.com/77</a></p>
<h1 id="태스크-큐-vs-마이크로태스크-큐"><a href="#태스크-큐-vs-마이크로태스크-큐" class="headerlink" title="태스크 큐 vs 마이크로태스크 큐"></a>태스크 큐 vs 마이크로태스크 큐</h1><p>2개의 큐 모두 콜백함수가 들어간다는 점에서 동일하지만 어떤 함수를 실행하느냐에 따라 어디로 들어가는지가 달라진다. 또한 명칭은 큐 (Queue) 이지만 실제 우리가 아는 자료구조의 큐와는 다르다. 엄밀히 말하자면 우선순위 큐 (Priority Queue) 라고 할 수 있는데, 이벤트 루프가 2개의 큐에서 태스크를 꺼내는 조건이 “제일 오래된 태스크” 이기 때문이다. (동작방식을 확인하고 싶다면 HTML 스펙 을 보자)<br>그럼 이제 어떤 함수들이 어떤 큐에 들어가는지 살펴보자.</p>
<ul>
<li>콜백함수를 태스크 큐에 넣는 함수들<ul>
<li>setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI 렌더링</li>
</ul>
</li>
<li>콜백함수를 마이크로태스크 큐에 넣는 함수들<ul>
<li>process.nextTick, Promise, Object.observe, MutationObserver<br>익숙한 함수인 Web API의 setTimeout() 의 콜백함수가 태스크 큐에 들어가고 Promise 의 콜백함수가 마이크로태스크 큐에 들어간다는 것을 알 수 있다. 이벤트 루프는 각 콜백함수를 태스크/마이크로태스크 큐에서 꺼내쓰는 것인데, 그렇다면 어떤게 먼저일까?</li>
</ul>
</li>
</ul>
<p>누가 먼저인가?<br>결론부터 말하자면, 마이크로태스크가 먼저이다.<br>이벤트 루프는 마이크로태스크 큐의 모든 태스크들을 처리한 다음, 태스크 큐의 태스크들을 처리한다. 따라서, Promise 의 콜백함수가 setTimeout() 의 콜백함수보다 먼저 처리된다. 예시를 보자.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/16/%EC%9B%90%EB%A6%AC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/"
                            aria-label=": 생명주기"
                        >
                            생명주기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:52:26-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="리액트-내부-동작-순서-정리-life-cycle"><a href="#리액트-내부-동작-순서-정리-life-cycle" class="headerlink" title="리액트 내부 동작 순서 정리 (life cycle)"></a>리액트 내부 동작 순서 정리 (life cycle)</h1><p>컴포넌트가 생성 되었을 때 리액트가 동작하는 방식입니다.</p>
<ol>
<li>컴포넌트를 초기화 합니다. (constructor를 통해 state를 초기화, 기본 프롭스값)</li>
<li>componentWillMount API 가 실행 됩니다.<br>이  API 는 컴포넌트가 DOM 위에 만들어 지기 전에 실행되는 API 입니다.</li>
</ol>
<ul>
<li>이 단계에서 DOM 처리는 불가능 합니다.</li>
</ul>
<ol start="3">
<li>렌더링을 진행합니다.</li>
<li>componentDidMount 는 렌더링이 완료되고 실행되는 API 입니다.</li>
</ol>
<ul>
<li>이 단계에서 다른 자바스크립트 프레임워크와 연동 및 setTimeout, setInteval, AJAX 등을 사용합니다.</li>
<li>DOM 처리가 가능합니다.</li>
</ul>
<p>두 번째 그래프는 프롭스가 변경되었을 때(전달 받을 때) 리액트가 동작하는 방식입니다.</p>
<ol>
<li>componentWillReceiveProps 는 상위 컴포넌트로 부터 props 를 받을 때 실행 됩니다.<br>이 단계는 props 에 따라 state 를 업데이트하는 경우에 사용하면 유용합니다.</li>
</ol>
<ul>
<li>이 단계에서 setState 를 해도 괜찮습니다.</li>
<li>componentWillReceiveProps API의 인자로 nextProps 가 들어옵니다. (바뀔 프롭스)</li>
</ul>
<ol start="2">
<li>shouldComponentUpdate 는 props 나 state 가 변경 되었을 때 다시 렌더링을 할지 말지 결정하는 API 입니다. <br>리턴값은 true 이거나 false 입니다.<br>만약 리턴값이 true 라면 다음 단계인 렌더링을 진행하지만, false 일 경우에는 Component Lifecycle 이 shouldComponentUpdate 단계에서 멈춥니다.</li>
</ol>
<ul>
<li>shouldComponentUpdate 의 인자로 nextProps 와 nextState 가 들어옵니다. (바뀔 프롭스와 스테이트)</li>
</ul>
<ol start="3">
<li>shouldComponentUpdate 리턴 값이 true 이면 다시 렌더링 합니다.</li>
<li>componentWillUpdate 는 컴포넌트가 업데이트 되기 전에 실행되는 API 입니다.</li>
</ol>
<ul>
<li>이 단계에서는 스테이트를 변경하면 안 됩니다. (setState 사용금지, state 가 변경되면 리렌더링 해야함, 무한루프발생)</li>
</ul>
<ol start="5">
<li>componentDidUpdate 는 렌더링과 모든 업데이트가 완료된 후에 실행되는 API 입니다.</li>
</ol>
<ul>
<li>이 단계에서는 스테이트를 변경하면 안 됩니다. (setState 사용금지, state 가 변경되면 리렌더링 해야함, 무한루프발생)</li>
<li>componentDidUpdate 의 인자로 prevProps 와 prevState 가 들어옵니다. (변경되기 이전의 프롭스, 스테이트)</li>
</ul>
<p>세 번째 그래프는 스테이트가 변경되었을 때 리액트가 작동하는 방식으로, <br>shouldComponentUpdate -&gt; render -&gt; componentWillUpdate  -&gt; componentDidUpdate 순으로 동작합니다.</p>
<p>네 번째 그래프는 컴포넌트가 삭제 될 때의 API로, 컴포넌트가 DOM 에서 사라진 후 실행됩니다.</p>
<p>Component Lifecycle 을 이용하면 각 단계마다 다른 인터페이스를 보여주거나 로딩 중 일때 로딩 아이콘을 보여주거나 하는 작업을 쉽게 할 수 있습니다.</p>
<p>다음 포스팅에서는 지금까지 공부한 개념들을 바탕으로 간단한 어플리케이션을 만들어 보도록 하겠습니다.<br>감사합니다.</p>
<p>Jwt </p>
<ul>
<li>JWT(Json Web Token)는 웹표준 (RFC 7519)으로 JSON 포맷을 이용해 정보를 가볍고 안전하게 전송하기 위한 Claim 기반의 Web Token이다.</li>
<li>서버만 알고 있는 Secret Key로 디지털 서명화되어있기 때문에 신뢰할 수 있다</li>
<li>보통 Authorization (로그인, SSO) 또는 안전한 정보 교환을 위해 사용된다.</li>
<li>JWT에서는 토큰 자체에 유저 정보를 담아서 HTTP 헤더에 전달하기에 유저 세션을 유지할 필요가 없다.</li>
</ul>
<p>JWT의 필요성</p>
<ul>
<li>Session의 한계<ul>
<li>Cookie는 정보를 클라이언트 측에 저장하고 Session은 정보를 서버측에 저장한다.</li>
<li>따라서 유저의 수가 너무 많으면 서버 과부하</li>
</ul>
</li>
<li>Scale Out의 한계<ul>
<li>서버 확장(scale out)시 세션 정보 동기화 문제</li>
</ul>
</li>
<li>REST API는 Stateless를 지향<ul>
<li>사용자의 상태 정보를 저장하지 않는 형태 ex) 세션, 쿠키</li>
</ul>
</li>
</ul>
<p>동작 과정</p>
<ol>
<li>클라이언트 로그인 요청 POST(id, pw)</li>
<li>서버는 (id, pw)가 맞는지 확인 후 맞다면 JWT를 Secret Key로 생성 후 전달</li>
<li>클라이언트는 Token을 로컬 쿠키에 저장</li>
<li>클라이언트는 서버에 요청할 때 항상 헤더에 Token을 포함시킴</li>
<li>서버는 요청을 받을 때마다 Secret Kye를 사용해Token이 유효한지 검증<ul>
<li>서버만이 Secret Key를 가지고 있기 때문에 검증 가능</li>
<li>Token이 검증되면 따로 username, pw를 검사하지 않아도 user identification 가능</li>
</ul>
</li>
<li>서버의 Response</li>
</ol>
<p>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ</p>
<p>레스트 호출 로직</p>
<p>1.[Axios란]<br>axios는 HTTP 클라이언트 라이브러리로써, 비동기 방식으로 HTTP 데이터 요청을 실행합니다.내부적으로 AXIOS는 직접적으로 XMLHttpRequest 를 다루지 않고 “AJAX 호출”을 할 수 있습니다.<br>promise를 객체로 리턴한다!</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EB%B0%94%EC%9D%B8%EB%94%A9/"
                            aria-label=": 바인딩"
                        >
                            바인딩
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:49:08-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>바인딩</p>
<p>자바스크립트에서 바인딩 (Javascript Binding)</p>
<p>자바스크립트에서 “this”에 대한 이해가 완벽히 되어있어야 한다.</p>
<p>자바스크립트에서 객체안의 메서드에서 this는 그 메서드가 포함된 object를 가리키게 된다.  </p>
<p>Var reference = obj.sayHello;<br>reference();</p>
<p>obj의 sayHello()를 다르게 출력해보면 undefined가 출력되는 것을 확인할 수 있다.<br>이 이유는 변수 reference에 담길 때 obj와의 관계가 상실되게 때문이다.<br>이럴 때 필요한 것이 “바.인.딩” 이다.</p>
<p>Var reference = obj.sayHello.bind(obj);<br>reference();</p>
<p>obj.sayHello()를 전달할 때 obj까지 바인딩시켜서 보내면 된다.<br>리액트에서도 마찬가지로 자바스크립트의 this가 사용되기때문에 바인딩이 필요하다.</p>
<p>리액트에서 바인딩 (React Binding)<br>React에서 컴포넌트에 이벤트메서드를 연결하는 방법 (=바인딩(binding))<br>다양한 방법이 있지만 리액트에서 주로 사용하는 방법은 컴포넌트의 생성자에서 바인딩 하기다.</p>
<p>class App extends React.Component {<br>    constructor() {<br>        super();<br>        this.state = {<br>              hidden: false,<br>        };<br>        this.update = this.update.bind(this);<br>    }<br>    update() {<br>        this.setState({<br>            hidden: true<br>        });<br>    }<br> <br>    render() {<br>        return &lt;div<br>            onClick={ this.update }<br>        /&gt;;<br>    }<br> <br>}</p>
<p>constructor() 에서 this.update = this.update.bind(this); 문장을 집어넣어서 바인딩시키면 render()에서 onClick={this.update}를 할 때 this가 App컴포넌트의 this라는 것을 알게 되는 것이다.</p>
<p>바인딩하는 방법중에 ‘autobind-decorator’를 사용해서 바인딩할 수 도 있다.<br>import autobind from ‘autobind-decorator’</p>
<p>mport React, { Component, PropTypes } from ‘react’;<br> <br>export default class Basic extends Component {<br>    state = {<br>           hidden: false,<br>      };<br> <br>      onClickButton = () =&gt; {<br>        this.setState(() =&gt; ({ hidden: true }));<br>      }<br>    <br>    render() {<br>        return (<br>              <div><br>                <button onClick={this.onClickButton}>숨기기</button><br>              </div><br>        );<br>    }<br>}</p>
<p>onClickButton 메서드를 “() =&gt;” arrow function으로 만들었다. (auto binding)<br>ES2015문법을 사용하는게 장기적으로 이득이니 적응하는게 좋을 듯 하다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EB%B0%94%EC%9D%B8%EB%94%A9/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"
                            aria-label=": 컴포넌트"
                        >
                            컴포넌트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:47:49-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="컴포넌트"><a href="#컴포넌트" class="headerlink" title="컴포넌트"></a>컴포넌트</h1><p> 컴포넌트란?</p>
<ul>
<li>컴포넌트 <br>처음 컴포넌트라는 이름을 들었을때 직관적으로 이해가 잘 안됬지만, 자바의 클래스와 객체로 분리하는 개념처럼 리액트에서는 컴포넌트로 분리한다고 생각하면 됩니다. 레이아웃을 컴포넌트라는 작은 단위로 나누어 코딩합니다. 이로인해 재사용성이 뛰어나고 이들을 모아 View형태로 코드를 짜기 때문에 코드도 이해하기 쉽고 협업에도 좋습니다.<br>React 컴포넌트는 상태 값을 이용해 UI를 표현합니다. 그리고, 컴포넌트 상태는 객체의 인스턴스 속성(Properties)을 이용해 관리하며 컴포넌트간에 단방향으로 데이터를 주고받는 props와 컴포넌트 내부에서 사용하는 state가 있습니다.</li>
</ul>
<p> - 기능을 단위별로 캡슐화하는 리액트의 기본 단컴포넌트란?<br> - 기능을 단위별로 캡슐화하는 리액트의 기본 단위다. <br> - 사용자가 보는 뷰는 이 컴포넌트들을 조합하여 만든다.<br> - 자바스크립트 함수 혹은 클래스이며 속성들을 이력받아들이며 내부적으로 각자의 상태를 관리한다.</p>
<p>리액트 컴포넌트는 요소를 그룹화하는 방법이다. <br>컴포넌트는 기능, 마크업, 스타일 그리고 기타 UI에 필요한 다른 요소들을 하나로 묶어 그룹화한다. <br>컴포넌트는 독립적이면서도 재사용이 가능하기 때문에 필요한 기능을 독자적으로 구성할 수 있다. </p>
<p>Data Flow</p>
<ul>
<li>단방향 데이터 흐름</li>
<li>데이터흐름 : 부모컴포넌트 =&gt; 자식컴포넌트</li>
<li>자식컴포넌트에서 직접적으로 부모컴포넌트에 전달하는 것은 불가능하다 - 간접적으로는 가능</li>
</ul>
<p>props<br>상위 컴포넌트가 하위 컴포넌트에게 내려주는 데이터 하위컴포넌트는 props를,</p>
<ul>
<li>단순히 사용만 할 수 있다</li>
<li>변경할 수 없다</li>
</ul>
<p>&lt;props 주는법&gt;</p>
<p>const App = () =&gt; (<br>  <div><br>    <h2>To Do List !</h2><br>    &lt;TodoList todos={[“eat pizza”, “eat rice”]} /&gt;<br>  </div><br>);</p>
<p>const TodoList = props =&gt; (<br>  <ul><br>    <li>{props.todos[0]}</li><br>    <li>{props.todos[1]}</li><br>  </ul><br>);</p>
<p>State<br>컴포넌트가 갖는 상태, 객체의 형태로 컴포넌트 내에서 보관하고 관리한다.</p>
<ul>
<li>class 컴포넌트로 작성되어야 한다</li>
<li>값을 변경할 땐 반드시 setState 메서드를 사용해야 한다</li>
<li>state 값이 변경되면 render() 함수가 실행된다.</li>
</ul>
<p>functional component vs class component</p>
<p>함수형 컴포넌트</p>
<ul>
<li>순수 자바스크립트 함수를 이용하여 컴포넌트를 정의한 것</li>
<li>선언하기가 편리하다</li>
<li>단순히 데이터를 받아들여 어떤 형태로 표시하기 때문에 ‘stateless’ 컴포넌트라고도 한다</li>
<li>주로 UI 렌더링을 담당한다 (예시 : Button 구성 요소)</li>
<li>state를 사용할 필요가 없는 경우 함수형 컴포넌트를 사용한다<ul>
<li>클래스형 컴포넌트보다 메모리 자원을 덜 사용한다</li>
</ul>
</li>
<li>state와 life cycle 기능을 사용할 수 없다 - v16.8 업데이트 이후 리액트 훅(Hooks)이라는 기능이 도입되어 사용이 가능하다고 한다..!!</li>
</ul>
<p>렌더링된 값들을 고정시킨다.</p>
<p>결과,</p>
<ul>
<li>함수형 컴포넌트 : Follow 버튼을 누르고 체크박스 옵션을 바꾸면 알림창에 Follow 버튼을 누르기전 옵션값이 알림창에 잘 들어가있다.</li>
<li>클래스형 컴포넌트 : Fllow 버튼을 누른 후 바꾼 옵션값이 알림창에 들어가있다<br>이 예제에서는 함수형 컴포넌트가 보여주는 패턴이 올바른 케이스이다. 내가 어떤 사람을 팔로우하고 다른 사람의 프로필로 이동했다 하더라도 컴포넌트가 이를 헷갈려서는 안된다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EB%B9%84%EB%8F%99%EA%B8%B0/"
                            aria-label=": 동기 비동기"
                        >
                            동기 비동기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:43:31-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="리액트-Async-Await"><a href="#리액트-Async-Await" class="headerlink" title="리액트 Async, Await"></a>리액트 Async, Await</h1><p>콜백함수 :</p>
<p>우리가 요청한 함수가 실행이 끝났을 때 우리에게 알려주는 함수</p>
<p>setTimeout 같은 함수는 콜백함수가 내장되어 있다!</p>
<p>Synchronous callback (print)</p>
<ul>
<li>받자마자 바로 콜백함수를 출력해주는 동기 콜백함수</li>
</ul>
<p>Asynchronous callback (print, timeout). -&gt; setTimeout 내장되어있음</p>
<ul>
<li>받고 일정 시간이 지나고 출력해주는 비동기 콜백함수</li>
</ul>
<p>이러한 콜백을 연결해서 코딩하게되면 콜백 지옥에 빠지게 된다.</p>
<ol>
<li>가독성이 떨어진다 어떻게 어디서 연결되어 있는지 알 수가 없다, 비즈니스 로직에 맞지않다.</li>
<li>디버깅 시 유지보수 하기가 어렵다</li>
</ol>
<p>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ</p>
<p>Promise</p>
<p>프로미스의 3가지 상태(states)<br>프로미스를 사용할 때 알아야 하는 가장 기본적인 개념이 바로 프로미스의 상태(states)입니다. 여기서 말하는 상태란 프로미스의 처리 과정을 의미합니다. new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.</p>
<ul>
<li><p>Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태</p>
<p>먼저 아래와 같이 new Promise() 메서드를 호출하면 대기(Pending) 상태가 됩니다.<br>new Promise() 메서드를 호출할 때 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 resolve, reject입니다.</p>
</li>
</ul>
<ul>
<li>Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태</li>
</ul>
<p>여기서 콜백 함수의 인자 resolve를 아래와 같이 실행하면 이행(Fulfilled) 상태가 됩니다.<br>그리고 이행 상태가 되면 아래와 같이 then()을 이용하여 처리 결과 값을 받을 수 있습니다.</p>
<ul>
<li>Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태</li>
</ul>
<p>new Promise()로 프로미스 객체를 생성하면 콜백 함수 인자로 resolve와 reject를 사용할 수 있다고 했습니다. 여기서 reject를 아래와 같이 호출하면 실패(Rejected) 상태가 됩니다.<br>그리고, 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 catch()로 받을 수 있습니다.</p>
<p>비동기 방식으로 동작하지만 호출이 성공하면 그떄 바로 성공했다고 콜백해주는 것!</p>
<ol>
<li><p>State : Pending -&gt; fulfilled or rejected</p>
</li>
<li><p>Producer vs Consumer</p>
</li>
</ol>
<p>1)producer</p>
<p>Const promise = new  promise(( resolve , reject ) =&gt; {<br>    doing some heavy work (network, read files)<br>console.log(‘doing something…’);<br>resolve(‘Ellie’);<br>reject(new Error(’no network’));<br>});</p>
<p>—&gt; promise 를 만드는 순간 네트워크 통신을 하게 된다!<br>—&gt; 새로운 promise를 만드는 순간 executor가 자동으로 실행된다</p>
<p>Resolve : 통신이 성공 했을 때 호출하는 콜백함수<br>Reject : 통신에 실패 했을 때 호출하는 콜백함수</p>
<p>2)Consumers : then, catch, finally</p>
<p>1] then은 성공 했을 때 !<br>Promise.then( value =&gt; {<br>Console.log(value);<br>});</p>
<p>2] catch는 실패 했을 때!<br>.catch(error =&gt; {<br>console.log(error);<br>}</p>
<p>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ</p>
<p>Async &amp; await</p>
<ol>
<li>Async</li>
</ol>
<p>Async 를 앞에쓰면 promise가 자동으로 붙게된다 !<br>비동기로 처리 할 것을 명시한다!</p>
<ol start="2">
<li>Await</li>
</ol>
<p>비동기 처리가 일어날 때 await가 걸린 함수는 해당 함수의 호출이 끝날 때 까지 기다려준다!</p>
<p>Async await 병렬처리</p>
<p>Promise.all( [getApple(), getBanana()] )<br>  —&gt; 해당 함수에 모두 promise를 걸고 모든 함수를 병렬처리 한다! </p>
<p>promis.race( [getApple(), getBanana()] )<br> —&gt; 딱 하나만 제일 먼저 수행되는 애를 출력한다 !</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EB%B9%84%EB%8F%99%EA%B8%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EA%B8%B0%EC%B4%88/"
                            aria-label=": 리액트 기초"
                        >
                            리액트 기초
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:42:00-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="리액트"><a href="#리액트" class="headerlink" title="리액트"></a>리액트</h1><p>리액트는 Component를 외부에서 사용자가 정의하고 그 Component들을 불러옴 으로써 웹을 구성한다.</p>
<p>이러한 사용방식으로 얻는 방법에서 크게 3가지의 장점이 존재한다.</p>
<ol>
<li>코드의 가독성을 늘려준다.</li>
<li>코드의 재사용성을 늘려준다.</li>
<li>유지보수 시 큰 이득이 있다.</li>
</ol>
<p>리액트를 사용하면서 자신이 Component를 만들 수 있고, 남이 작성해 놓은 Component를 사용 할 수도 있다!</p>
<p>리액트를 작업할 때 webpack 이나 parcel 같은 번들러를 이용해서 작업을 합니다. 모든 모듈이나 여러가지 라이브러리를 동시에 합쳐서 하나의 .js 파일로 내보내는거죠. 또한 리액트 파일은 JSX 문법으로 작성되거나 최신 JS 문법으로 작성되기 때문에, babel 을 사용해서 브라우저 호환성을 생각해야 합니다.</p>
<h1 id="리액트-특징"><a href="#리액트-특징" class="headerlink" title="리액트 특징"></a>리액트 특징</h1><ol>
<li>JSX 문법</li>
</ol>
<p>자바스크립트 안에서 HTML 문법을 사용해서 View를 구성 할 수 있게 도와주는 자바스크립트 문법</p>
<ol start="2">
<li>Component 기반</li>
</ol>
<p>웹 페이지를 작성 할 때 여러부분을 분할해서 코드의 재사용성과 유지보수성을 증가</p>
<ol start="3">
<li>Virtual DOM</li>
</ol>
<p>가성 DOM을 만들어서 수정 된 사항이 있을 때 전체 코들르 검토하는 것이 아닌 수정된 일부만 수정하게 되어 효율적으로 코딩을 할 수 있게 도와주며 완성된 DOM은 실제 DOM으로 옮겨 유저에게 보여주는 프론트를 제공한다.</p>
<h1 id="리액트-폴더"><a href="#리액트-폴더" class="headerlink" title="리액트 폴더"></a>리액트 폴더</h1><ol>
<li>public</li>
</ol>
<p>가상 DOM이 들어갈 빈 껍데기 html이 존재하는 폴더</p>
<ol start="2">
<li>Src</li>
</ol>
<ol>
<li><p>index.js<br>app.js 에서 생성된 리액트 코드를 index.js에서 불러온 후, public에 있는 index.html의 id가 Root인 곳에다가 넣어줌</p>
</li>
<li><p>App.js<br>리액트, 리액트 컴포넌트를 부른 후에 App이라는 클래스를 생성한 후, 리액트 컴포넌트를 상속받습니다. 그렇게되면 리액트 컴포넌트 메소드를 사용 할 수 있습니다.</p>
</li>
</ol>
<p>render() 메소드는 리액트 컴포넌트인데, 화면서 html뷰를 생성해주는 역할을 합니다. reture으로 받는 값들은 나중에 html코드로 바뀌게됩니다.</p>
<p>그리고 export 문법을 이용해서 내보냅니다.</p>
<p><strong>html 코드를 여러 개의 리액트 파일로 분할해서 작업을 할 수가 있다는 것 입니다. 또한 그렇게 되면 여러 사람이 협업을 하는 것도 쉬워지고, 코드의 수정도 특정 부분만 하면 되기 때문에 이점이 많아지게 됩니다.</strong></p>
<h1 id="props와-state"><a href="#props와-state" class="headerlink" title="props와 state"></a>props와 state</h1><ol>
<li>State는 현재 컴포넌트 내에서 변경이 가능하다.</li>
<li>Props는 현재 컴포넌트 내에서 변경이 불가능하다.<br>(예전 리액트 버전에서는 가능했으나 현재 버전에서는 사용하지 않는 것을 추천)</li>
<li>Props와 State 모두 하위 컴포넌트에 상속이 가능하다.</li>
</ol>
<p>props와 state는 데이터를 다룰 때 사용하는 개념입니다.</p>
<p>state는 하나의 컴포넌트가 가질 수 있는 변경 가능한 데이터이다.</p>
<ul>
<li>컴포넌트를 렌더링 할 때 새로운 데이터를 생성해야 한다던지, 아니면 기존의 데이터를 참고해서 새로운 데이터를 만들어야 할 때 사용할 수 있습니다<br>즉, 현재 컴포넌트 안에서 새로운 데이터를 만들어 낼 때 사용합니다.</li>
</ul>
<p>props는 변경이 불가능한 데이터이지만, 상속을 통해 바꿔 줄 수는 있다.</p>
<h1 id="리액트-생명주기"><a href="#리액트-생명주기" class="headerlink" title="리액트 생명주기"></a>리액트 생명주기</h1><p>Mounting: 리액트 코드 첫 렌더링의 시작</p>
<ol>
<li><p>constructor : 생성자가 먼저 동작함.</p>
</li>
<li><p>render : 렌더링을 위해 작성해둔 JSX를 return 해주는 메소드가 작동</p>
</li>
<li><p>componentDidMount : 리액트 코드가 HTML로 변환되어 화면에 나타남. (첫 렌더링 직후에만 한번 일어남!)</p>
</li>
</ol>
<p>Updateing : 리액트 state나 props가 업데이트 되었을 때</p>
<p>(: setState 메소드 : state를 업데이트 하려면 반드시 setState를 수행해야 합니다.)</p>
<p>(: props : 부모 컴포넌트에서 setState를 수행하여 현재 컴포넌트가 가지고 있는 props가 업데이트 되었을 때)</p>
<ol>
<li><p>render : state나 props 같잉 보여주어야 하는 데이터가 업데이트 되었으면 다시 render를 수행</p>
</li>
<li><p>componentDidUpdate: 컴포넌트가 업데이트 되었을 때 수행되는 메소드로 인자를 받는다. prevProps , prevState를 받는다!</p>
</li>
</ol>
<p>Unmounting : 컴포넌트가 사라질 때</p>
<p>컴포넌트에 setInterval과 같은 작업을 진행했을 때에 이 부분은 컴포넌트가 단순히 사라진다고 해서 없어지지 않습니다. 메모리에 좀비처럼 상주할 가능성이 있는 변수들을 여기서 null 을 할당함으로 사용되지 않을 작업들을 해제해줄 수 있습니다</p>
<p>componentWillUnMount : 컴포넌트가 사라질 떄에만 수행됩니다. 이 때 setInterval과 같은 작ㅇ버을 했을 경우에 여기서 해제시켜 주면된다!</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EA%B8%B0%EC%B4%88/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/10/14/Ajax/"
                            aria-label=": Ajax"
                        >
                            Ajax
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-10-14T03:24:31-07:00">
	
		    Oct 14, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><br>

<p><strong><code>A</code>synchronous 비동기</strong> <br><br><br><strong><code>J</code>avaScript</strong> <br><br><br><strong><code>A</code>nd</strong> <br><br><br><strong><code>X</code>ml</strong></p>
<br>

<hr>

<br>

<h2 id="초창기-웹"><a href="#초창기-웹" class="headerlink" title="초창기 웹?"></a>초창기 웹?</h2><br>

<p>하나의 수정된 정보를 보여주기 위해서 모든 <code>HTML 코드</code>들을 다시 호출해서 보여줌</p>
<p align="center"> <img src="https://user-images.githubusercontent.com/62025746/96861263-b5650800-1418-11eb-940b-30b6f12b3201.png" width="600px"> </p>

<br>

<hr>

<br>

<h2 id="Ajax의-장점-1"><a href="#Ajax의-장점-1" class="headerlink" title="Ajax의 장점 - 1"></a>Ajax의 장점 - 1</h2><br>

<p>필요한 부분만 별도로 요청하고, 응답받아 처리 할 수 있음 <br><br>모든 데이터를 전부 업로드 할 필요가 없어져서 속도 개선 및 비용 절감에 좋음!</p>
<p align="center"> <img src="https://user-images.githubusercontent.com/62025746/96861268-b6963500-1418-11eb-8225-5fbdc89b3665.png" width="600px"> </p>

<br>

<hr>

<br>


<h2 id="Ajax의-장점-2"><a href="#Ajax의-장점-2" class="headerlink" title="Ajax의 장점 - 2"></a>Ajax의 장점 - 2</h2><p><strong>비동기 방식으로 페이지를 새로고침 하지 않고도 필요한 데이터를 받아와서 내용을 업데이트 하기 때문에 클라이언트의 대기시간을 줄일 수 있다.</strong></p>
<br>

<p align="center"> <img src="https://user-images.githubusercontent.com/62025746/95962130-f1103880-0e40-11eb-92d4-4293d0195a00.png" width="600px"> </p>

<p><br><br></p>
<h3 id="동기-비동기-방식의-차이점"><a href="#동기-비동기-방식의-차이점" class="headerlink" title="동기/비동기 방식의 차이점"></a>동기/비동기 방식의 차이점</h3><br>

<ul>
<li><p>동기(synchronous : 동시에 일어나는)</p>
<ul>
<li>동기는 말 그대로 동시에 일어난다는 뜻입니다. 요청과 그 결과가 동시에 일어난다는 약속인데요. 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 합니다. <br><br></li>
<li>요청과 결과가 한 자리에서 동시에 일어남 <br><br></li>
<li>A노드와 B노드 사이의 작업 처리 단위(transaction)를 동시에 맞추겠다.</li>
</ul>
</li>
<li><p>비동기(Asynchronous : 동시에 일어나지 않는)</p>
<ul>
<li>비동기는 동시에 일어나지 않는다를 의미합니다. 요청과 결과가 동시에 일어나지 않을거라는 약속입니다. <br><br></li>
<li>요청한 그 자리에서 결과가 주어지지 않음 <br><br></li>
<li>노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다. </li>
</ul>
<p><br><br></p>
</li>
</ul>
<h3 id="동기-비동기-방식의-장단점"><a href="#동기-비동기-방식의-장단점" class="headerlink" title="동기/비동기 방식의 장단점"></a>동기/비동기 방식의 장단점</h3><br>

<p> <strong>동기와 비동기는 상황에 따라서 각각의 장단점이 있습니다.</strong>  <br><br></p>
<p> <strong>동기방식은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점이 있고,</strong>  <br><br></p>
<p> <strong>비동기방식은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있습니다.</strong></p>
<br>

<hr>

<br>

<h2 id="비동기-방식의-종류"><a href="#비동기-방식의-종류" class="headerlink" title="비동기 방식의 종류"></a>비동기 방식의 종류</h2><ul>
<li><p><strong>$(“ “).load( )</strong></p>
</li>
<li><p><strong>$.get( ),$.post( )</strong></p>
</li>
<li><p><strong>$.getJSON( )</strong></p>
</li>
<li><p><strong>$.ajax( )</strong></p>
<br>

<hr>

</li>
</ul>
<h3 id="비동기-방식의-종류-“-“-load"><a href="#비동기-방식의-종류-“-“-load" class="headerlink" title="비동기 방식의 종류 - $(“ “).load( )"></a>비동기 방식의 종류 - $(“ “).load( )</h3><br>

<p align="center"> <img src="https://user-images.githubusercontent.com/62025746/95962119-ef467500-0e40-11eb-8305-f1fb54d35871.png" width="600px"> </p>

<br>

<hr>

<br>

<h3 id="비동기-방식의-종류-get-post"><a href="#비동기-방식의-종류-get-post" class="headerlink" title="비동기 방식의 종류 - $.get( ),$.post( )"></a>비동기 방식의 종류 - $.get( ),$.post( )</h3><br>

<p align="center"> <img src="https://user-images.githubusercontent.com/62025746/95962111-ece41b00-0e40-11eb-9905-5fa594ad517a.png" width="600px"> </p>

<br>

<hr>

<br>

<h3 id="비동기-방식의-종류-getJSON"><a href="#비동기-방식의-종류-getJSON" class="headerlink" title="비동기 방식의 종류 - $.getJSON( )"></a>비동기 방식의 종류 - $.getJSON( )</h3><br>

<p align="center"> <img src="https://user-images.githubusercontent.com/62025746/95962114-eeadde80-0e40-11eb-9cd2-26a7cc660dd6.png" width="600px"> </p>

<br>

<hr>

<br>

<h3 id="비동기-방식의-종류-ajax"><a href="#비동기-방식의-종류-ajax" class="headerlink" title="비동기 방식의 종류 - $.ajax( )"></a>비동기 방식의 종류 - $.ajax( )</h3><br>

<p align="center"> <img src="https://user-images.githubusercontent.com/62025746/95962116-eeadde80-0e40-11eb-9e40-fe92eeee4c07.png" width="600px"> </p>

<br>

<hr>

<br>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/10/14/Ajax/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 이상권. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">이상권</h4>
        
            <div id="about-card-bio"><p>미래의 백엔드 개발자</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>개발자</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Busan
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover2.png');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
